<!DOCTYPE HTML>
<html lang="zh">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
	<title>Hello Jun</title>
    <script src="src/FlatSystem.js"></script>
    
</head>
<body>
    <div>
        <canvas width="1000" height="500" id="helloworld"></canvas>
        <canvas width="1000" height="500" id="helloworld2"></canvas>
    </div>
    <script>
        function $(id){
            return document.getElementById(id);
        }
        var ctx = new FlatSystem($('helloworld').getContext("2d"), 1000, 500);
        ctx.setCalibration(40);
        ctx.setProportion(2);
        ctx.onlyQuadrant(1);
        ctx.init();
        var ctx2 = new FlatSystem($('helloworld2').getContext("2d"), 1000, 500);
        ctx2.setCalibration(40);
        ctx2.setProportion(2);
        ctx2.onlyQuadrant(1);
        ctx2.init();
        
        function Line(x1,y1, x2,y2){//开始点，重点 2点决定一条直线（线段）
            this.x1 = x1;
            this.y1 = y1;
            
            this.x2 = x2;
            this.y2 = y2;
            this.init();
        }
        Line.prototype = {
            constructor:Line,
            init:function(){
                
                if(this.x1-this.x2 == 0 ){//无斜率线段 线段平行于y轴，斜率为0  平行于x轴this.a = 0;
                    //斜率不存在直线表示为 x = 30;//(30为实数)
                    this.a = null;
                    this.b = 0;
                    this.x = this.x1;
                    this.fx = function(y){//y可取任何数
                       return y;
                    };
                }else{//正常线段
                    this.a = (this.y1-this.y2)/(this.x1-this.x2);
                    this.b = this.y1 - this.a*this.x1;
                }
                
            },
            fx:function(x){
                return this.a * x + this.b;
            },
            draw:function(ctx){
                //console.log(this.x1, this.y1, this.x2, this.y2);
                ctx.printLine(this.x1, this.y1, this.x2, this.y2);
            },
            isOnlinePoint:function(point){// point是否在线段上
   
                var a = this.a;
                var b = this.b;
               // x1
                //console.log(a,b);
                if(a == null){
                    //x 取值正确 y在线段两点之间
                    return Math.abs(point.x - this.x) <= 1 && Math.min(this.y1, this.y2) <= point.y && Math.max(this.y1, this.y2) >= point.y;
                   //if(Math.abs(point.x - this.x) <= 1 && Math.min(this.y1, this.y2) <= point.y && Math.max(this.y1, this.y2) >= point.y){
                  //      return {line:this, x:point.x, y:point,y};
                  // }else{
                  //      return false;
                  // }
                }
                //console.log((Math.abs(point.y -( a * point.x + b ))));
                return  Math.min(this.x1, this.x2) <= point.x && Math.max(this.x1, this.x2) >= point.x && (Math.abs(point.y -( a * point.x + b )) < 1);
               ////if(Math.min(this.x1, this.x2) <= point.x && Math.max(this.x1, this.x2) >= point.x && (Math.abs(point.y -( a * point.x + b )) < 1)){
               // return {line:this, x:point.x, y:point,y};
               //}
               //return false;
            },
            isLineIntersect:function(line){//是否与line线段相交
                
                var point = this.getIntersectPoint(line);
                //console.log(point);
                ctx2.printPoint(point.x, point.y);
                if(point){//直线有交点
                   // return this.isOnlinePoint(point) && line.isOnlinePoint(point);
                    if(this.isOnlinePoint(point) && line.isOnlinePoint(point)){
                        return {line:this, x:point.x, y:point.y};
                    }
                   return false;
                }
                
                return false;
            },
            getIntersectPoint:function(line){//获取焦点 不相交返回false相交返回 交点坐标 必须先确定 isLineIntersect返回值为真 此方法才会正确
                var a1 = this.a;
                var b1 = this.b;

                var a2 = line.a;
                var b2 = line.b;
                
            
                if(a1 == null && a2 == null){//平行于 y
                    return false;
                }
    
                if( (a1!=null ? a1/a2 : null) != b1/b2 ){//直线有交点
                    /**
                        y1 = a1*x1 + b1; 
                        y2 = a2*x1 + b2;
                        以上两条直线有焦点，那么焦点坐标p(x,y) 如下表示
                    */
          
                    var x,y;
                    
                    /**a1  a2不会同时为 null*/
                    
                    x = - (b2 - b1) / (a2 - a1);
                    y = line.fx(x);

                    if(a1 == null){
                        x = this.x;
                        y = line.fx(x);
                    }
                    
                    if(a2 == null){
                        x = line.x;
                        y = this.fx(x);
                    }
                    
                    return {x:x,y:y};
                    
                }
                
                return false;
            }
        };
    </script>
	<script>
        
        function test(){//普通测试
            var line = {x1:30,y1:100,x2:200,y2:300};
            
            var point = {
                x:30,
                y:110
            };
            var line1 = new Line(line.x1, line.y1, line.x2, line.y2);
            line1.draw(ctx);
            ctx.printPoint(point.x, point.y, 5,5);
            return line1.isOnlinePoint(point);

        };
        
        function test2(){
            
            // y = 3x + 5;
            var line = {
                x1:400,y1:400, x2:400, y2:-900
            };
            
            // y = 0.5x + 10;
            var line2 = {
               x1:20, y1:20, x2:2000,y2:20
            };
            /**
			var line2 = {
                x1:20,y1:20, x2:1000, y2:510
            };
            */
			
            var linObj1 = new Line(line.x1,line.y1, line.x2, line.y2);
            var linObj2 = new Line(line2.x1,line2.y1, line2.x2, line2.y2);
            linObj1.draw(ctx);
            linObj2.draw(ctx);
            return linObj1.isLineIntersect(linObj2);
        };
       // test2();
		
		
		/**
			简单的动画开始
		*/
		
		/**画布*/
		
		function AnimateCtx(ctx){
			this.context = ctx;
			this.elem = [];
			this.setInter = null;
            this.dps = 30;
		}
		AnimateCtx.prototype = {
			constructor:AnimateCtx,
			init:function(){
				var _this = this;
				this.setInter = setInterval(function(){
					_this.draw();
				}, this.dps);
			},
			clear:function(){
				this.context.clear();
			},
			draw:function(){
				this.context.init();
				for(var i=0; i<this.elem.length; i++){
					this.elem[i].draw(this.context);
				}
			},
			stop:function(){
				clearInterval(this.setInter);
			},
			addElem:function(elem){
				this.elem.push(elem);
			}
			
		};
		
		/*小球*/
		function SmallBall(x, y, width, height){
            
			this.x = x || 10;
			this.y = y || 10;
            
			this.r = 10;//半径
			this.g = 0.6;//重力加速度 设置为10 1000毫秒 10/1000 * 60(60毫秒动画刷新一次)
			this.t = 0;
			this.interval = null;
            this.action = 1;//抛球方向 1向上  2向下
            this.elasticity = 0.9;//弹力恢复系数0 - 1
            this.dps = 30;
            this.ut = 0;
            this.u = 0.5;//抛出力
            this.deg = 10;
            this.z = 0.01;//空气阻力
			//this.init();
		};
		SmallBall.prototype = {
			constructor:SmallBall,
            easeOut: function(t,b,c,d){
                return -c * ((t=t/d-1)*t*t*t - 1) + b;
            },
            init:function(){//计算了抛射角度
                this.t += this.action;
                var ux = Math.cos(this.getK(this.deg)) * this.u;
                var uy = Math.sin(this.getK(this.deg)) * this.u;
                //console.log(ux);
                var uo = ux;
                var g = this.g + uy;
                
                var x = uo * this.t;// - 0.5*this.z*(uo*uo) * this.t;//x = uot - 空气阻力
                
                var y = -0.5 * g * Math.pow(this.t, 2) * this.action;//
                
                //console.log(this.x , y);
                var isIntersect = this.isIntersect(this.x+x, this.y+y);
                
                if( isIntersect && this.action > 0 ){
                    this.action *= -1;
                    this.y = isIntersect.y;
                    this.x = isIntersect.x;
                    this.t = Math.floor( this.t*this.elasticity );
                }else{
                    this.x += x;
                    this.y += y;
                }   
                
               if(this.t <= 2 && this.action < 0){
                    this.action = -this.action;
                }
                
                ctx2.printPoint(this.x, this.y);
            },
            init3:function(){//平抛运动
                this.t += this.action;
                
                this.qt = this.t;
                
                var x = this.u * this.t;
                var y = -0.5 * this.g * Math.pow(this.t, 2) * this.action;
                
                var isIntersect = this.isIntersect(this.x+x, this.y+y);
                
                if( isIntersect && this.action > 0 ){
                    if(this.t <= 3){
                        this.stop();
                        return ;
                    }
                    this.y = isIntersect.y;
                    this.x = isIntersect.x;
                    this.action = -this.action;
                    this.t = Math.floor( this.t*this.elasticity );
                }else{
                    this.x += x;
                    this.y += y;
                }
                
                if(this.t <= 2 && this.action < 0){
                    this.action = -this.action;
                }
                
                ctx2.printPoint(this.x+x, this.y+y);
            },
            getK:function(deg){
                return deg/180 * Math.PI;
            },
			draw:function(ctx){
                ctx.context.beginPath();
                ctx.context.arc(ctx.getx(this.x+this.r*2),ctx.gety(this.y+this.r*2),this.r,0,Math.PI+(Math.PI*3)/2, true);
                ctx.context.fill();
 
				//ctx.printPoint(this.x, this.y, this.width, this.height);
			},
			move:function(){
				//this.x += 10;
                var _this = this;
                this.interval = setInterval(function(){
                    _this.init();
                }, this.dps);
			},
            stop:function(){
                clearInterval(this.interval);
            },
			isIntersect:function(x, h){
               
				var line1 = {//物体运动线
					x1:this.x, y1:this.y, x2:x,y2:h
				};

				var line2 = {//墙壁
					x1:20, y1:20, x2:1700,y2:200
				};
                
                var lineObj1 = new Line(line1.x1,line1.y1, line1.x2, line1.y2);
                var lineObj2 = new Line(line2.x1,line2.y1, line2.x2, line2.y2);
                
                lineObj1.draw(ctx2);
                ctx2.fillText(this.t, x, this.y+h);
                return lineObj1.isLineIntersect(lineObj2);
			}
		};
		
		/*线段*/
		
		
		/***/
		var smallBallMove = new AnimateCtx(ctx);
		var smallBall = new SmallBall(200, 500, 10, 10);
            //smallBall.init();
            smallBall.move();
 
		var line1 = new Line(20, 20, 1700, 200);
		smallBallMove.init();
		smallBallMove.addElem(smallBall);

        smallBallMove.addElem(line1);
		
		/***/
		
        
    </script>
</body>
</html>