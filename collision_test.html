<!DOCTYPE HTML>
<html lang="zh">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
	<title>Hello Jun</title>
    <script src="src/FlatSystem.js"></script>
    
</head>
<body>
    <div>
        <canvas width="1000" height="500" id="helloworld"></canvas>
        <canvas width="1000" height="500" id="helloworld2"></canvas>
    </div>
    <script>
        function $(id){
            return document.getElementById(id);
        }
        var ctx = new FlatSystem($('helloworld').getContext("2d"), 1000, 500);
        ctx.setCalibration(40);
        ctx.setProportion(2);
        ctx.onlyQuadrant(1);
        ctx.init();
        var ctx2 = new FlatSystem($('helloworld2').getContext("2d"), 1000, 500);
        ctx2.setCalibration(40);
        ctx2.setProportion(2);
        ctx2.onlyQuadrant(1);
        ctx2.init();
        
        function Line(x1,y1, x2,y2){//开始点，重点 2点决定一条直线（线段）
            this.x1 = x1;
            this.y1 = y1;
            
            this.x2 = x2;
            this.y2 = y2;
            this.init();
        }
        Line.prototype = {
            constructor:Line,
            init:function(){
                
                if(this.x1-this.x2 == 0 ){//无斜率线段 线段平行于y轴，斜率为0  平行于x轴this.a = 0;
                    //斜率不存在直线表示为 x = 30;//(30为实数)
                    this.a = null;
                    this.b = 0;
                    this.x = this.x1;
                    this.fx = function(y){//y可取任何数
                       return y;
                    };
                }else{//正常线段
                    this.a = (this.y1-this.y2)/(this.x1-this.x2);
                    this.b = this.y1 - this.a*this.x1;
                }
                
            },
            fx:function(x){
                return this.a * x + this.b;
            },
            draw:function(ctx){
                //console.log(this.x1, this.y1, this.x2, this.y2);
                ctx.printLine(this.x1, this.y1, this.x2, this.y2);
            },
            isOnlinePoint:function(point){// point是否在线段上
   
                var a = this.a;
                var b = this.b;
               // x1
                //console.log(a,b);
                if(a == null){
                    //x 取值正确 y在线段两点之间
                    return Math.abs(point.x - this.x) <= 1 && Math.min(this.y1, this.y2) <= point.y && Math.max(this.y1, this.y2) >= point.y;
                    //return Math.min(x1, x2) <= point.x && Math.max(x1, x2) >= point.x && Math.min(y1, y2) <= point.y && Math.max(y1, y2) >= point.y;
                }
                //console.log((Math.abs(point.y -( a * point.x + b ))));
                return  Math.min(this.x1, this.x2) <= point.x && Math.max(this.x1, this.x2) >= point.x && (Math.abs(point.y -( a * point.x + b )) < 1);
            },
            isLineIntersect:function(line){//是否与line线段相交
                
                var point = this.getIntersectPoint(line);
                //console.log(point);
                ctx2.printPoint(point.x, point.y);
                if(point){//直线有交点
                    return this.isOnlinePoint(point) && line.isOnlinePoint(point);
                }
                
                return false;
            },
            getIntersectPoint:function(line){//获取焦点 不相交返回false相交返回 交点坐标 必须先确定 isLineIntersect返回值为真 此方法才会正确
                var a1 = this.a;
                var b1 = this.b;

                var a2 = line.a;
                var b2 = line.b;
                
               
                if(a1 == null && a2 == null){//平行于 y
                    return false;
                }
                
                if( a1/a2 != b1 / b2 ){//直线有交点
                    /**
                        y1 = a1*x1 + b1; 
                        y2 = a2*x1 + b2;
                        以上两条直线有焦点，那么焦点坐标p(x,y) 如下表示
                    */
          
                    var x,y;
                    
                    /**a1  a2不会同时为 null*/
                    
                    x = - (b2 - b1) / (a2 - a1);
                    y = line.fx(x);

                    if(a1 == null){
                        x = this.x;
                        y = line.fx(x);
                    }
                    
                    if(a2 == null){
                        x = line.x;
                        y = this.fx(x);
                    }
                    
                    return {x:x,y:y};
                    
                }
                
                return false;
            }
        };
    </script>
	<script>
        
        function test(){//普通测试
            var line = {x1:30,y1:100,x2:200,y2:300};
            
            var point = {
                x:30,
                y:110
            };
            var line1 = new Line(line.x1, line.y1, line.x2, line.y2);
            line1.draw(ctx);
            ctx.printPoint(point.x, point.y, 5,5);
            return line1.isOnlinePoint(point);

        };
        
        function test2(){
            
            // y = 3x + 5;
            var line = {
                x1:400,y1:400, x2:400, y2:-900
            };
            
            // y = 0.5x + 10;
            var line2 = {
               x1:20, y1:20, x2:2000,y2:20
            };
            /**
			var line2 = {
                x1:20,y1:20, x2:1000, y2:510
            };
            */
			
            var linObj1 = new Line(line.x1,line.y1, line.x2, line.y2);
            var linObj2 = new Line(line2.x1,line2.y1, line2.x2, line2.y2);
            linObj1.draw(ctx);
            linObj2.draw(ctx);
            return linObj1.isLineIntersect(linObj2);
        };
       // test2();
		
		
		/**
			简单的动画开始
		*/
		
		/**画布*/
		
		function AnimateCtx(ctx){
			this.context = ctx;
			this.elem = [];
			this.setInter = null;
            this.dps = 30;
		}
		AnimateCtx.prototype = {
			constructor:AnimateCtx,
			init:function(){
				var _this = this;
				this.setInter = setInterval(function(){
					_this.draw();
				}, this.dps);
			},
			clear:function(){
				this.context.clear();
			},
			draw:function(){
				this.context.init();
				for(var i=0; i<this.elem.length; i++){
					this.elem[i].draw(this.context);
				}
			},
			stop:function(){
				clearInterval(this.setInter);
			},
			addElem:function(elem){
				this.elem.push(elem);
			}
			
		};
		
		/*小球*/
		function SmallBall(x, y, width, height){
			this.x = x || 10;
			this.y = y || 10;
			this.width = width || 10;
			this.height = height || 10;
			this.g = 0.6;//重力加速度 设置为10 1000毫秒 10/1000 * 60(60毫秒动画刷新一次)
			this.t = 0;
			this.interval = null;
            this.action = 1;
            this.elasticity = 0.9;//弹力恢复系数0 - 1
            this.k = -Math.PI/3;//小球的运动斜率0 --- Math.PI/2
            this.b = y - this.k*x;//根据斜率算出直线b
            this.dps = 30;
            this.lidu = 5;
			//this.init();
		};
		SmallBall.prototype = {
			constructor:SmallBall,
            easeOut: function(t,b,c,d){
                return -c * ((t=t/d-1)*t*t*t - 1) + b;
            },
			init:function(){//直线运动
                this.t += this.action;
                this.x += 3; //可以直接给x递增
                //x* x = -2py; 抛物线的方程
                //x = Math.sqrt(-2*p*y);
                //this.x += 0.5*this.lidu*(this.t*this.t);
                var gt = 0.5*this.g*(this.t*this.t) * this.action;//加速度

				var h = this.y - gt;
                //var x = Math.floor(h / this.k)+this.b;
                   
                if( this.isIntersect(this.x,h) && this.action > 0 ){
                    this.y = new Line(this.x,this.y, this.x, h).getIntersectPoint(new Line(20,20,2000,20)).y;
                    //this.x = x = Math.floor(this.y / this.k)+this.b;
                    this.action = -this.action;
                    this.t = Math.floor( this.t*this.elasticity );
                    if(this.t == 0){
                        this.stop();
                    }
                }else{
                    this.y = h;
                }
                
                if(this.t <= 0){
                    this.action = -this.action;
                }

                //this.x = x;

               
			},
           // init:function(){
                //x2=-2py 抛物线
                //for();
           // },
			draw:function(ctx){
                //this.init();
				ctx.printPoint(this.x, this.y, this.width, this.height);
			},
			move:function(){
				//this.x += 10;
                var _this = this;
                this.interval = setInterval(function(){
                    _this.init();
                }, this.dps);
			},
            stop:function(){
                clearInterval(this.interval);
            },
			isIntersect:function(x, h){
               
				var line1 ={//物体运动线
					x1:this.x, y1:this.y, x2:x,y2:h
				};

				var line2 = {//墙壁
					x1:20, y1:20, x2:2000,y2:20
				};
                
                var lineObj1 = new Line(line1.x1,line1.y1, line1.x2, line1.y2);
                var lineObj2 = new Line(line2.x1,line2.y1, line2.x2, line2.y2);
                
                lineObj1.draw(ctx2);
                
                return lineObj1.isLineIntersect(lineObj2);
			}
		};
		
		/*线段*/
		
		
		
		var smallBallMove = new AnimateCtx(ctx);
		var smallBall = new SmallBall(200, 500, 10, 10);
            //smallBall.init();
            smallBall.move();
 
		var line1 = new Line(20, 20, 2000, 20);
		smallBallMove.init();
		smallBallMove.addElem(smallBall);

        smallBallMove.addElem(line1);
		
		/***/
		
        
    </script>
</body>
</html>